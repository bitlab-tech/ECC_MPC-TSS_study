# Distributed Key Generation (DKG) with Feldman's Scheme

This repository provides an implementation of [Distributed Key Generation (DKG)](https://en.wikipedia.org/wiki/Distributed_key_generation) based on [Feldman's verifiable secret sharing scheme](https://en.wikipedia.org/wiki/Verifiable_secret_sharing#Feldman's_scheme). **DKG** allows a group of participants to collaboratively generate a public/private key pair while ensuring that no single participant learns the private key, enhancing security and fault tolerance in cryptographic systems.

This POC is partly based on the research paper: [Threshold Diffie — Hellman Protocol](https://www.mathnet.ru/php/archive.phtml?wshow=paper&jrnid=pdma&paperid=536&option_lang=eng) (2021) done by **D.N. Kolegov and Yu.R. Khalniyazova**. A translation can be found [here](translation.pdf).

## Overview

In a DKG protocol, multiple participants generate a shared secret (the private key) without relying on a trusted third party. Each participant contributes to the key generation process, and the final key can be reconstructed only when a sufficient number of participants cooperate. This is particularly useful in scenarios where security is critical, such as in threshold cryptography.

## Table of Contents
- [Distributed Key Generation (DKG) with Feldman VSS](#distributed-key-generation-dkg-with-feldman-vss)
- [Feldman VSS Additive Property](#feldman-vss-additive-property)
- [Security Considerations](#security-considerations)
- [Application to the Diffie-Hellman Protocol](#application-to-the-diffie-hellman-protocol)
- [Conclusion](#conclusion)
- [Example](#example)
  - [Example Setup](#example-setup)
  - [Step 1: Secret Sharing using Feldman VSS](#step-1-secret-sharing-using-feldman-vss)
  - [Step 2: Verifying Shares](#step-2-verifying-shares)
  - [Step 3: Final Share Computation](#step-3-final-share-computation)
  - [Reconstruct the secret](#reconstruct-the-secret)
- [Key Points to Note](#key-points-to-note)

<small><i><a href='http://ecotrust-canada.github.io/markdown-toc/'>Table of contents generated with markdown-toc</a></i></small>


## Distributed Key Generation (DKG) with Feldman VSS
- Index Assignment: Each participant $P_j$ is assigned an index $j$, which is used in the polynomial for share generation. For simplicity, these indices are often just the participant numbers $j$, though they could be other distinct values known to all.

- Share Generation: In Feldman’s VSS scheme, each participant $P_j$ receives a share of the form $f(j)$, where $f$ is a polynomial chosen by the dealer. In this case, each participant plays the role of the dealer in turn, sharing a random value $u_i$  (this is often done to ensure that no single participant holds too much control over the key generation).

- Final Key Share Computation: After each participant shares their value $u_i$ , the shares from all participants are combined. Thanks to the additive property of Feldman’s VSS, the final share of the secret key $x$ is the sum of the individual shares: $x=\sum_{i}u_i$ This sum is distributed among participants without anyone ever knowing the actual value of $x$.

## Feldman VSS Additive Property
- Feldman’s scheme has an important **additive homomorphism** property: If participants are given shares $f_i(j)$ of two secrets $a$ and $b$, then by adding the shares of $f_a(j)$ and $f_b(j)$, the participants obtain a share of $a+b$ without needing to explicitly know either $a$ or $b$.

- In this context, the secret key $x$ is generated by adding up the random values shared by each participant, allowing the final private key to be distributed among the group without revealing the key.

## Security Considerations
- Verifiability: Each participant can verify the correctness of their received share using the public commitments that are broadcasted during the VSS process. This prevents dishonest participants from distributing incorrect shares.

- Privacy: No individual participant can reconstruct the full private key on their own, ensuring that the secret remains distributed.

## Application to the Diffie-Hellman Protocol
- The generated private key shares are used in the Diffie-Hellman protocol for secure key exchange. Each participant contributes their share of the private key to compute a shared public key, which can then be used for secure communications within the group.

## Conclusion
This distributed approach avoids the need for trust in a single central dealer and ensures that the private key remains protected through the use of secure cryptographic mechanisms.

## Example
Let's clarify how this distributed key generation (DKG) protocol using Feldman’s Verifiable Secret Sharing (VSS) works.

### Example Setup
- Group size $n=5$: There are five participants $P_1$, $P_2$, $P_3$, $P_4$ and $P_5$.

- Threshold $t=3$: At least three participants are needed to reconstruct the secret.

- Prime $p=23$: A small prime used for modular arithmetic.

- Prime $q=11$: Another prime such that $q \mid (p - 1)$, i.e., $11 \mid (21 - 1) = 22$.

Each participant will contribute to generating the shared private key.

### Step 1: Secret Sharing using Feldman VSS
Each participant $P_j$ selects a random secret $u_i$ , and they will generate shares of their secret using a polynomial $f_j(x)$.

Here’s how each participant generates their share:

Participant $P_1$ selects $u_1 = 2$:
- They choose a random polynomial $f(x)= 2 + 4x + 8x^2 \ mod \ q$, where $2$ is the constant term, and $4$ and $8$ are random coefficients.
- They then compute shares ​$f(1)$, $f(2)$, $f(3)$, $f(4)$ and $f(5)$ for each participant, including themselves:
  - $f_1(1) = 3$
  - $f_1(2) = 9$
  - $f_1(3) = 9$
  - $f_1(4) = 3$
  - $f_1(5) = 2$
- Participant $P_1$  broadcasts commitments $C_1$​ for verification using Feldman VSS.

Participant $P_2$ selects $u_2 = 7$:
- They choose a random polynomial $f(x)= 7 + 9x + 4x^2 \ mod \ q$
- They then compute shares:
  - $f_2(1) = 9$
  - $f_2(2) = 8$
  - $f_2(3) = 4$
  - $f_2(4) = 8$
  - $f_2(5) = 9$
- Participant $P_2$  broadcasts commitments $C_2$.

Participant $P_3$ selects $u_3 = 4$:
- They choose a random polynomial $f(x)= 4 + 4x + 6x^2 \ mod \ q$
- They then compute shares:
  - $f_3(1) = 3$
  - $f_3(2) = 3$
  - $f_3(3) = 4$
  - $f_3(4) = 6$
  - $f_3(5) = 9$
- Participant $P_3$  broadcasts commitments $C_3$.

Participant $P_4$ selects $u_4 = 9$:
- They choose a random polynomial $f(x)= 4 + 2x + 5x^2 \ mod \ q$
- They then compute shares:
  - $f_4(1) = 5$
  - $f_4(2) = 0$
  - $f_4(3) = 5$
  - $f_4(4) = 9$
  - $f_4(5) = 1$
- Participant $P_4$  broadcasts commitments $C_4$

Participant $P_5$ selects $u_5 = 4$:
- They choose a random polynomial $f(x)= 4 + 8x + 1x^2 \ mod \ q$
- They then compute shares:
  - $f_5(1) = 2$
  - $f_5(2) = 2$
  - $f_5(3) = 4$
  - $f_5(4) = 8$
  - $f_5(5) = 3$
- Participant $P_5$  broadcasts commitments $C_5$

### Step 2: Verifying Shares
Each participant now holds the following shares:
- $P_1$ :
  - $f_1(1) = 3, f_2(1) = 9, f_3(1) = 3, f_4(1) = 5, f_5(1) = 2$.
- $P_2$ : 
  - $f_1(2) = 9, f_2(2) = 8, f_3(2) = 3, f_4(2) = 0, f_5(2) = 2$.
- $P_3$ : 
  - $f_1(3) = 9, f_2(3) = 4, f_3(3) = 4, f_4(3) = 5, f_5(3) = 4$.
- $P_4$ : 
  - $f_1(4) = 3, f_2(4) = 8, f_3(4) = 6, f_4(4) = 9, f_5(4) = 8$.
- $P_5$ : 
  - $f_1(5) = 2, f_2(5) = 9, f_3(5) = 9, f_4(5) = 1, f_5(5) = 3$.

Each participant can use the public commitments broadcasted by the others to verify their received shares are valid.

### Step 3: Final Share Computation
Now, to generate the final secret key shares:

- Each participant adds their shares received from the others. For example:
  - $P_1$ computes their final share:

    $share_1 = f_1(1) + f_2(1) + f_3(1) + f_4(1) + f_5(1) = 3 + 9 + 3 + 5 + 2 = 22 \ mod \ 11 = 0$

  - $P_2$ computes their final share:
  
    $share_2 = f_1(2) + f_2(2) + f_3(2) + f_4(2) + f_5(2) = 9 + 8 + 3 + 0 + 2 = 22 \ mod \ 11 = 0$

  - $P_3$ computes their final share:
  
    $share_3 = f_1(3) + f_2(3) + f_3(3) + f_4(3) + f_5(3) = 9 + 4 + 4 + 5 + 4 = 26 \ mod \ 11 = 4$

  - $P_4$ computes their final share:
  
    $share_4 = f_1(4) + f_2(4) + f_3(4) + f_4(4) + f_5(4) = 3 + 8 + 6 + 9 + 8 = 34 \ mod \ 11 = 1$

  - $P_5$ computes their final share:
  
    $share_5 = f_1(5) + f_2(5) + f_3(5) + f_4(5) + f_5(5) = 2 + 9 + 9 + 1 + 3 = 24 \ mod \ 11 = 2$

### Reconstruct the secret

If three participants, say $P_1$, $P_2$ and $P_5$, come together to reconstruct the secret, they use Lagrange interpolation with their shares:
Using $share_1 = 0$, $share_2 = 0$, $share_5 = 2$ they reconstruct the secret, which is the sum of all $u_i$.

$f(0) =  \sum_{j=1}^{t} y_j \lambda_j \ mod \ q = (y_1\lambda_1 + y_2\lambda_2 + y_3\lambda_3) \ mod \ q$

$\lambda_j = \prod_{\substack{1 \leq m \leq t \\ m \neq j}} \frac{0 - x_m}{x_j - x_m} \ mod \ q$

- For $share_1$:

  $\lambda_1 = \frac{0 - x_2}{x_1 - x_2} \cdot \frac{0 - x_3}{x_1 - x_3} = \frac{0 - 2}{1 - 2} \cdot \frac{0 - 5}{1 - 5} = \frac{-2}{-1} \cdot \frac{-5}{-4} = 2 \cdot \frac{5}{4} \ mod \ 11$

  Since we're working modulo $p$, we'll simplify each step:
  - $\frac{5}{4} \ mod \ 11 = 5 \cdot 4^{-1} \ mod \ 11$, where $4^{-1}$ is the modular inverse of $4 \ mod \ 11$.
  - Compute modular inverse of $4 \ mod \ 11: 4^{-1} \ mod \ 11 = 3$ (from [Fermat's Little Theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem) or using [the extended Euclidean algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)).
  - So, $\frac{5}{4} \ mod \ 11 = 5 \cdot 3 = 15 \ mod \ 11 = 4$

  Thus,

  $\lambda_1 = 2 \cdot 4 = 8 \ mod \ 11 = 8$

- For $share_2$:

  $\lambda_2 = \frac{0 - x_1}{x_2 - x_1} \cdot \frac{0 - x_3}{x_2 - x_3} = \frac{0 - 1}{2 - 1} \cdot \frac{0 - 5}{2 - 5} = \frac{-1}{1} \cdot \frac{-5}{-3} = -1 \cdot \frac{5}{3} \ mod \ 11$

  Now compute $\frac{5}{3} \ mod \ 11$:
  - The modular inverse of $3 \ mod \ 11$ is $3^{-1} \ mod \ 11 = 4$.
  - So, $\frac{5}{3} \ mod \ 11 = 5 \cdot 4 = 20 \ mod \ 11 = 9$

  Thus,

  $\lambda_2 = -1 \cdot 9 = -9 \ mod \ 11 = 2$

- For $share_5$:

  $y_3 = \frac{0 - x_1}{x_3 - x_1} \cdot \frac{0 - x_2}{x_3 - x_2} = \frac{0 - 1}{5 - 1} \cdot \frac{0 - 2}{5 - 2} = \frac{-1}{4} \cdot \frac{-2}{3} \ mod \ 11$

  Now compute $\frac{1}{4} \ mod \ 11$ and $\frac{2}{3} \ mod \ 11$:
  - $\frac{1}{4} \ mod \ 11  = 4^{-1} \ mod \ 11 = 3$.
  - $\frac{2}{3} \ mod \ 11 = 2 \cdot 3^{-1} \ mod \ 11 = 2 \cdot 4 = 8 \ mod \ 11 = 8$.

  Thus,

  $\lambda_3 = 3 \cdot 8 = 24 \ mod \ 11 = 2$

Compute $f(0)$:
- Substitute the values: 
  - $y_1 = 0, y_2 = 0, y_3 = 2$
  - $\lambda_1 = 8, \lambda_2 = 2, \lambda_3 = 2$


$f(0) = y_1\lambda_1 + y_2\lambda_2 + y_3\lambda_3 = 0 \cdot 8 + 0 \cdot 2 + 2 \cdot 2 \ mod \ 11 = 4 \ mod \ 11 = 4 \ (1)$

Since each participant contributed random secrets, the reconstructed secret $x$ will be:

$x = u_1 + u_2 + u_3 + u_4 + u_5 = 2 + 7 + 4 + 9 + 4 = 26 \ mod \ 11 =  4 \ (2)$

From $(1)$ and $(2)$ we have:

$f(0) = \sum_{j=1}^{n}u_j = 4$

This secret is shared among participants, and no individual participant knows the full secret before reconstruction.

## Key Points to Note
- Each participant holds a share of the secret key, but no one knows the entire key on their own.
- The verification process ensures that no participant can provide a fraudulent share without detection.
- The final secret key is only reconstructed when enough participants (at least $t$) combine their shares.

This example shows how distributed key generation works without a trusted dealer, ensuring privacy and security in a cryptographic group setting, like in the Diffie-Hellman protocol.