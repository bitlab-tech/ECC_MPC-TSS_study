# Feldman's Verifiable Secret Sharing (VSS) Scheme

This repository contains a **proof of concept (POC)** implementation of a Verifiable Secret Sharing (VSS) scheme using commitments and share verification. The scheme demonstrates how to split a secret among multiple participants (shares) and ensure the validity of these shares using cryptographic commitments.

## Overview

The core cryptographic technique used for this scheme involves [Feldman Verifiable Secret Sharing (Feldman VSS)](https://en.wikipedia.org/wiki/Verifiable_secret_sharing#Feldman's_scheme), which builds on [Shamir's Secret Sharing (SSS)](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing) with added verification using modular arithmetic.

## Mathematical Explanation

### Modular arithmetic:

When implementing this scheme, it's important to first choose primes $p$ and $q$ such that $q \mid p - 1$. This choice affects how arithmetic operations are performed in the algorithm:

  - The polynomial $f(x)$ used to generate the shares is calculated modulo $q$.
  - The commitments (used for verifying the shares) and all computations involving these commitments are calculated modulo $p$.

Then $g$ needs to be chosen:
  - $g$ is the generator of a subgroup of order $q$ in the multiplicative group modulo $p$, meaning: $g^q \ mod \ p=1$, and no smaller power of $g$ equals $1 \ mod \ p$.

### Secret Splitting

The secret sharing scheme works by representing the secret as the constant term of a polynomial:
$f(x) = s + a_1 x + a_2 x^2 + \dots + a_{t-1} x^{t-1}$
Where:
- $s$ is the secret.
- $t$ is the threshold of shares required to reconstruct the secret.
- $a_1, a_2, \dots, a_{t-1}$ are randomly chosen coefficients (mod $q$, where $q$ is a prime).

Each share is generated by evaluating the polynomial at different points $x$:
$y_i = f(x_i) \mod q$

### Generating Commitments

To ensure the validity of each share, **commitments** to the polynomial coefficients are generated. Given a generator $g$, we compute commitments as follows:
- The commitment to the constant term $s$ is $C_0 = g^s \mod p$.
- For each coefficient $a_i$, the commitment is $C_i = g^{a_i} \mod p$.

Thus, the commitments are:
$\text{Commitments} = [C_0, C_1, C_2, \dots, C_{t-1}]$
Where each $C_i$ corresponds to the polynomial's coefficients.

### Verifying Shares

To verify the validity of a share $(x_i, y_i)$, we check that:

$g^{y_i} \mod p = \prod_{j=0}^{t-1} C_j^{x_i^j} \mod p = C_0 \cdot C_1^{x_i^1} \cdot C_2^{x_i^2} \dots \cdot C_t^{x_i^{t}} \mod p$

Where the left-hand side is computed directly from the share, and the right-hand side is reconstructed using the commitments. If both sides match, the share is considered valid.

## Example

Given a setup of:

$secret \ s = 7,$
$t = 3 \ and \ n = 5$

$a_1 = 8, a_2 = 3$

$p = 23, \ q = 11, \ g = 2$


### Step 1: Secret Sharing Polynomial

The polynomial to generate shares for $t=3$ is:

$f(x) = s + a_1x + a_2x^2$

$ \ \ \ \ \ \ \ \ \ = 7 + 8x + 3x^2$

5 shares are generated as:

$f(1) = 7 + 8(1) + 3(1)^2 \ mod \ q  = 18 \ mod \ 11 = 7 $

$f(2) = 7 + 8(2) + 3(2)^2 \ mod \ q  = 35 \ mod \ 11 = 2$

$f(3) = 7 + 8(3) + 3(3)^2 \ mod \ q  = 58 \ mod \ 11 = 3$

$f(4) = 7 + 8(4) + 3(4)^2 \ mod \ q  = 87 \ mod \ 11 = 10$

$f(5) = 7 + 8(5) + 3(5)^2 \ mod \ q  = 122 \ mod \ 11 = 1$

### Step 2: Public Commitments

Commitments are generated as $C_j = g^{a_j}$ and are published to all participants:

$C_0 = g^s \ mod \ p = 2^7 \ mod \ 23 = 13$

$C_1 = g^{a_1} \ mod \ p = 2^8 \ mod \ 23 = 3$

$C_2 = g^{a_2} \ mod \ p = 2^3 \ mod \ 23 = 8$

### Step 3: Share verification

Each participant can now calculate the proof:

$g^{f({x_i})} \ mod \ p = g^{y_i} \ mod \ p$

of their share.

$proof_{share1} = g^{y_1} \ mod \ p = 2^7 \ mod \ 23 = 13$

$proof_{share2} = g^{y_2} \ mod \ p = 2^2 \ mod \ 23 = 4$

$proof_{share3} = g^{y_3} \ mod \ p = 2^3 \ mod \ 23 = 8$

$proof_{share4} = g^{y_4} \ mod \ p = 2^10 \ mod \ 23 = 12$

$proof_{share5} = g^{y_5} \ mod \ p = 2^1 \ mod \ 23 = 2$

They now verify if their proof is correct by checking if:

$g^{y_i} \ mod \ p = proof_{share \ i} = \prod_{j=0}^{t-1} C_j^{i^j} \mod p$

Verification:

$verification_{share1} = C_0 \cdot C^{1^1}_1 \cdot C^{1^2}_2 \ mod \ p = 13 \cdot 3^{1} \cdot 8^1 \ mod \ 23 = 13$

$verification_{share2} = C_0 \cdot C^{2^1}_1 \cdot C^{2^2}_2 \ mod \ p = 13 \cdot 3^{2^1} \cdot 8^{2^2} \ mod \ 23 = 13 \cdot 3^{2} \cdot 8^{4} \ mod \ 23 = 4$

$verification_{share3} = C_0 \cdot C^{3^1}_1 \cdot C^{3^2}_2 \ mod \ p = 13 \cdot 3^{3^1} \cdot 8^{3^2} \ mod \ 23 = 13 \cdot 3^{3} \cdot 8^{9} \ mod \ 23 = 8$

$verification_{share4} = C_0 \cdot C^{4^1}_1 \cdot C^{4^2}_2 \ mod \ p = 13 \cdot 3^{4^1} \cdot 8^{4^2} \ mod \ 23 = 13 \cdot 3^{4} \cdot 8^{16} \ mod \ 23 = 12$

$verification_{share5} = C_0 \cdot C^{5^1}_1 \cdot C^{5^2}_2 \ mod \ p = 13 \cdot 3^{5^1} \cdot 8^{5^2} \ mod \ 23 = 13 \cdot 3^{5} \cdot 8^{25} \ mod \ 23 = 2$

Since:

$proof_{share1} = verification_{share1} = 13$

$proof_{share2} = verification_{share2} = 4$

$proof_{share3} = verification_{share3} = 8$

$proof_{share4} = verification_{share4} = 12$

$proof_{share5} = verification_{share5} = 2$

All shares are valid.

This is to demonstrate that participants can verify if their share is valid.

They can also check if any other participant's share is valid without having to know the share value - by verifying the provided proof against the published commitments.

## Implementation

The code implements the following functions:

- **`split(secret, n, t)`**: Splits a secret into `n` shares, where `t` shares are required to reconstruct the secret. The function also generates cryptographic commitments for verification.
- **`combine(shares)`**: Reconstructs the secret from a subset of `t` shares using Lagrange interpolation.
- **`gen_proof(share)`**: Generates a cryptographic proof for a given share using its corresponding commitment.
- **`verify_proof(commitments, proof)`**: Verifies a share by checking if the proof matches the commitments.

