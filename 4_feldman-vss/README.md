# Feldman's Verifiable Secret Sharing (VSS) Scheme

This repository contains a **proof of concept (POC)** implementation of a Verifiable Secret Sharing (VSS) scheme using commitments and share verification. The scheme demonstrates how to split a secret among multiple participants (shares) and ensure the validity of these shares using cryptographic commitments.

## Overview

The core cryptographic technique used for this scheme involves [Feldman Verifiable Secret Sharing (Feldman VSS)](https://en.wikipedia.org/wiki/Verifiable_secret_sharing#Feldman's_scheme), which builds on [Shamir's Secret Sharing (SSS)](https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing) with added verification using modular arithmetic.

## Mathematical Explanation

### Secret Splitting

The secret sharing scheme works by representing the secret as the constant term of a polynomial:
$f(x) = s + a_1 x + a_2 x^2 + \dots + a_{t-1} x^{t-1}$
Where:
- $s$ is the secret.
- $t$ is the threshold of shares required to reconstruct the secret.
- $a_1, a_2, \dots, a_{t-1}$ are randomly chosen coefficients (mod $q$, where $q$ is a prime).

Each share is generated by evaluating the polynomial at different points $x$:
$y_i = f(x_i) \mod q$

### Generating Commitments

To ensure the validity of each share, **commitments** to the polynomial coefficients are generated. Given a generator $g$, we compute commitments as follows:
- The commitment to the constant term $s$ is $C_0 = g^s \mod p$.
- For each coefficient $a_i$, the commitment is $C_i = g^{a_i} \mod p$.

Thus, the commitments are:
$\text{Commitments} = [C_0, C_1, C_2, \dots, C_{t-1}]$
Where each $C_i$ corresponds to the polynomial's coefficients.

### Verifying Shares

To verify the validity of a share $(x_i, y_i)$, we check that:
$g^{y_i} \mod p = C_0 \cdot C_1^{x_i} \cdot C_2^{x_i^2} \dots \cdot C_{t-1}^{x_i^{t-1}} \mod p$
Where the left-hand side is computed directly from the share, and the right-hand side is reconstructed using the commitments. If both sides match, the share is considered valid.

## *Modulus:

When implementing this scheme, it's important to choose primes $p$ and $q$ such that $q \mid p - 1$. This choice affects how arithmetic operations are performed in the algorithm:
  - The polynomial $f(x)$ used to generate the shares is calculated modulo $q$.
  - The commitments (used for verifying the shares) and all computations involving these commitments are calculated modulo $p$.


## Implementation

The code implements the following functions:

- **`split(secret, n, t)`**: Splits a secret into `n` shares, where `t` shares are required to reconstruct the secret. The function also generates cryptographic commitments for verification.
- **`combine(shares)`**: Reconstructs the secret from a subset of `t` shares using Lagrange interpolation.
- **`gen_proof(share)`**: Generates a cryptographic proof for a given share using its corresponding commitment.
- **`verify_proof(commitments, proof, i)`**: Verifies a share by checking if the proof matches the commitments.

